# 生成组合图
png("combined_treemap.png", width = 20, height = 20, units = "cm", res = 300)  # 降低组合图的分辨率
# 使用grid来绘制组合图
grid.newpage()
# 读取每个图像的大小
img1 <- png::readPNG("tm1_2019.png")
img2 <- png::readPNG("tm1_2020.png")
img3 <- png::readPNG("tm1_2021.png")
img4 <- png::readPNG("tm1_2022.png")
img5 <- png::readPNG("tm1_2023.png")
# 获取图像尺寸
img_sizes <- list(dim(img1), dim(img2), dim(img3), dim(img4), dim(img5))
# 计算每个图像的显示大小（单位：cm）
display_sizes <- lapply(img_sizes, function(size) {
list(width = size[2] / 300 * 2.54, height = size[1] / 300 * 2.54)  # 根据新的分辨率计算
})
# 放大倍数（降低放大倍数）
scale_factor <- 1.01  # 可以根据需要设置更小的放大倍数
# 根据实际图像大小和放大倍数绘制组合图
pushViewport(viewport(layout = grid.layout(3, 3,
widths = unit(c(0.3, 0.3, 0.3), "npc"),
heights = unit(c(0.3, 0.3, 0.3), "npc"))))
# 在指定位置绘制每个图，使用图像的实际尺寸和放大倍数
grid.raster(img1, width = unit(display_sizes[[1]]$width * scale_factor, "cm"),
height = unit(display_sizes[[1]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 2))  # 2019 (2,2)
grid.raster(img2, width = unit(display_sizes[[2]]$width * scale_factor, "cm"),
height = unit(display_sizes[[2]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 3))  # 2020 (2,3)
grid.raster(img3, width = unit(display_sizes[[3]]$width * scale_factor, "cm"),
height = unit(display_sizes[[3]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 1, layout.pos.col = 2))  # 2021 (1,2)
grid.raster(img4, width = unit(display_sizes[[4]]$width * scale_factor, "cm"),
height = unit(display_sizes[[4]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 1))  # 2022 (2,1)
grid.raster(img5, width = unit(display_sizes[[5]]$width * scale_factor, "cm"),
height = unit(display_sizes[[5]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 3, layout.pos.col = 2))  # 2023 (3,2)
dev.off()
# 保存每个图为 PNG 文件，使用较低的分辨率
saveTreemapPNG <- function(treemap, filename, label_size, width, height) {
png(filename, width = width * 0.5, height = height * 0.5, units = "cm", res = 600)  # 降低分辨率
drawTreemap(
treemap,
color_palette = custom_pal_1,
color_type = "custom_color",
color_level = 2,
label_level = c(1, 2),
label_size = label_size,
label_color = "black",
border_size = c(0.5, 0.1),
border_color = gray(0.6),
position = c(1, 1)
)
dev.off()
}
# 保存每个图的 PNG，设置对应的大小
saveTreemapPNG(tm1, "tm1_2019.png", 4, 9.4, 9.4)  # 2019
saveTreemapPNG(tm2, "tm1_2020.png", 4, 8.8, 8.8)  # 2020
saveTreemapPNG(tm3, "tm1_2021.png", 3, 6.0, 6.0)  # 2021
saveTreemapPNG(tm4, "tm1_2022.png", 4, 7.8, 7.8)  # 2022
saveTreemapPNG(tm5, "tm1_2023.png", 5, 10.0, 10.0) # 2023
# 生成组合图
png("combined_treemap.png", width = 30, height = 30, units = "cm", res = 600)  # 降低组合图的分辨率
# 使用grid来绘制组合图
grid.newpage()
# 读取每个图像的大小
img1 <- png::readPNG("tm1_2019.png")
img2 <- png::readPNG("tm1_2020.png")
img3 <- png::readPNG("tm1_2021.png")
img4 <- png::readPNG("tm1_2022.png")
img5 <- png::readPNG("tm1_2023.png")
# 获取图像尺寸
img_sizes <- list(dim(img1), dim(img2), dim(img3), dim(img4), dim(img5))
# 计算每个图像的显示大小（单位：cm）
display_sizes <- lapply(img_sizes, function(size) {
list(width = size[2] / 300 * 2.54, height = size[1] / 300 * 2.54)  # 根据新的分辨率计算
})
# 放大倍数（降低放大倍数）
scale_factor <- 1.01  # 可以根据需要设置更小的放大倍数
# 根据实际图像大小和放大倍数绘制组合图
pushViewport(viewport(layout = grid.layout(3, 3,
widths = unit(c(0.3, 0.3, 0.3), "npc"),
heights = unit(c(0.3, 0.3, 0.3), "npc"))))
# 在指定位置绘制每个图，使用图像的实际尺寸和放大倍数
grid.raster(img1, width = unit(display_sizes[[1]]$width * scale_factor, "cm"),
height = unit(display_sizes[[1]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 2))  # 2019 (2,2)
grid.raster(img2, width = unit(display_sizes[[2]]$width * scale_factor, "cm"),
height = unit(display_sizes[[2]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 3))  # 2020 (2,3)
grid.raster(img3, width = unit(display_sizes[[3]]$width * scale_factor, "cm"),
height = unit(display_sizes[[3]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 1, layout.pos.col = 2))  # 2021 (1,2)
grid.raster(img4, width = unit(display_sizes[[4]]$width * scale_factor, "cm"),
height = unit(display_sizes[[4]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 1))  # 2022 (2,1)
grid.raster(img5, width = unit(display_sizes[[5]]$width * scale_factor, "cm"),
height = unit(display_sizes[[5]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 3, layout.pos.col = 2))  # 2023 (3,2)
dev.off()
# 保存每个图为 PNG 文件，使用较低的分辨率
saveTreemapPNG <- function(treemap, filename, label_size, width, height) {
png(filename, width = width * 0.5, height = height * 0.5, units = "cm", res = 800)  # 降低分辨率
drawTreemap(
treemap,
color_palette = custom_pal_1,
color_type = "custom_color",
color_level = 2,
label_level = c(1, 2),
label_size = c(3,1),
label_color = "black",
border_size = c(5, 3),
border_color = gray(0.6),
position = c(1, 1)
)
dev.off()
}
# 保存每个图的 PNG，设置对应的大小
saveTreemapPNG(tm1, "tm1_2019.png", 4, 9.4, 9.4)  # 2019
saveTreemapPNG(tm2, "tm1_2020.png", 4, 8.8, 8.8)  # 2020
saveTreemapPNG(tm3, "tm1_2021.png", 3, 6.0, 6.0)  # 2021
saveTreemapPNG(tm4, "tm1_2022.png", 4, 7.8, 7.8)  # 2022
saveTreemapPNG(tm5, "tm1_2023.png", 5, 10.0, 10.0) # 2023
# 生成组合图
png("combined_treemap.png", width = 30, height = 30, units = "cm", res = 1000)  # 降低组合图的分辨率
# 使用grid来绘制组合图
grid.newpage()
# 读取每个图像的大小
img1 <- png::readPNG("tm1_2019.png")
img2 <- png::readPNG("tm1_2020.png")
img3 <- png::readPNG("tm1_2021.png")
img4 <- png::readPNG("tm1_2022.png")
img5 <- png::readPNG("tm1_2023.png")
# 获取图像尺寸
img_sizes <- list(dim(img1), dim(img2), dim(img3), dim(img4), dim(img5))
# 计算每个图像的显示大小（单位：cm）
display_sizes <- lapply(img_sizes, function(size) {
list(width = size[2] / 300 * 2.54, height = size[1] / 300 * 2.54)  # 根据新的分辨率计算
})
# 放大倍数（降低放大倍数）
scale_factor <- 1.01  # 可以根据需要设置更小的放大倍数
# 根据实际图像大小和放大倍数绘制组合图
pushViewport(viewport(layout = grid.layout(3, 3,
widths = unit(c(0.3, 0.3, 0.3), "npc"),
heights = unit(c(0.3, 0.3, 0.3), "npc"))))
# 在指定位置绘制每个图，使用图像的实际尺寸和放大倍数
grid.raster(img1, width = unit(display_sizes[[1]]$width * scale_factor, "cm"),
height = unit(display_sizes[[1]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 2))  # 2019 (2,2)
grid.raster(img2, width = unit(display_sizes[[2]]$width * scale_factor, "cm"),
height = unit(display_sizes[[2]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 3))  # 2020 (2,3)
grid.raster(img3, width = unit(display_sizes[[3]]$width * scale_factor, "cm"),
height = unit(display_sizes[[3]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 1, layout.pos.col = 2))  # 2021 (1,2)
grid.raster(img4, width = unit(display_sizes[[4]]$width * scale_factor, "cm"),
height = unit(display_sizes[[4]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 1))  # 2022 (2,1)
grid.raster(img5, width = unit(display_sizes[[5]]$width * scale_factor, "cm"),
height = unit(display_sizes[[5]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 3, layout.pos.col = 2))  # 2023 (3,2)
dev.off()
# 保存每个图为 PNG 文件，使用较低的分辨率
saveTreemapPNG <- function(treemap, filename, label_size, width, height) {
png(filename, width = width * 0.5, height = height * 0.5, units = "cm", res = 600)  # 降低分辨率
drawTreemap(
treemap,
color_palette = custom_pal_1,
color_type = "custom_color",
color_level = 2,
label_level = c(1, 2),
label_size = c(1,0.5),
label_color = "black",
border_size = c(3, 1),
border_color = gray(0.6),
position = c(1, 1)
)
dev.off()
}
# 保存每个图的 PNG，设置对应的大小
saveTreemapPNG(tm1, "tm1_2019.png", 4, 9.4, 9.4)  # 2019
saveTreemapPNG(tm2, "tm1_2020.png", 4, 8.8, 8.8)  # 2020
saveTreemapPNG(tm3, "tm1_2021.png", 3, 6.0, 6.0)  # 2021
saveTreemapPNG(tm4, "tm1_2022.png", 4, 7.8, 7.8)  # 2022
saveTreemapPNG(tm5, "tm1_2023.png", 5, 10.0, 10.0) # 2023
# 生成组合图
png("combined_treemap.png", width = 30, height = 30, units = "cm", res = 800)  # 降低组合图的分辨率
# 使用grid来绘制组合图
grid.newpage()
# 读取每个图像的大小
img1 <- png::readPNG("tm1_2019.png")
img2 <- png::readPNG("tm1_2020.png")
img3 <- png::readPNG("tm1_2021.png")
img4 <- png::readPNG("tm1_2022.png")
img5 <- png::readPNG("tm1_2023.png")
# 获取图像尺寸
img_sizes <- list(dim(img1), dim(img2), dim(img3), dim(img4), dim(img5))
# 计算每个图像的显示大小（单位：cm）
display_sizes <- lapply(img_sizes, function(size) {
list(width = size[2] / 300 * 2.54, height = size[1] / 300 * 2.54)  # 根据新的分辨率计算
})
# 放大倍数（降低放大倍数）
scale_factor <- 1.01  # 可以根据需要设置更小的放大倍数
# 根据实际图像大小和放大倍数绘制组合图
pushViewport(viewport(layout = grid.layout(3, 3,
widths = unit(c(0.3, 0.3, 0.3), "npc"),
heights = unit(c(0.3, 0.3, 0.3), "npc"))))
# 在指定位置绘制每个图，使用图像的实际尺寸和放大倍数
grid.raster(img1, width = unit(display_sizes[[1]]$width * scale_factor, "cm"),
height = unit(display_sizes[[1]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 2))  # 2019 (2,2)
grid.raster(img2, width = unit(display_sizes[[2]]$width * scale_factor, "cm"),
height = unit(display_sizes[[2]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 3))  # 2020 (2,3)
grid.raster(img3, width = unit(display_sizes[[3]]$width * scale_factor, "cm"),
height = unit(display_sizes[[3]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 1, layout.pos.col = 2))  # 2021 (1,2)
grid.raster(img4, width = unit(display_sizes[[4]]$width * scale_factor, "cm"),
height = unit(display_sizes[[4]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 1))  # 2022 (2,1)
grid.raster(img5, width = unit(display_sizes[[5]]$width * scale_factor, "cm"),
height = unit(display_sizes[[5]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 3, layout.pos.col = 2))  # 2023 (3,2)
dev.off()
# 保存每个图为 PNG 文件，使用较低的分辨率
saveTreemapPNG <- function(treemap, filename, label_size, width, height) {
png(filename, width = width * 0.5, height = height * 0.5, units = "cm", res = 600)  # 降低分辨率
drawTreemap(
treemap,
color_palette = custom_pal_1,
color_type = "custom_color",
color_level = 2,
label_level = c(1, 2),
label_size = c(1,0.5),
label_color = "black",
border_size = c(1.5, 0.5),
border_color = gray(0.6),
position = c(1, 1)
)
dev.off()
}
# 保存每个图的 PNG，设置对应的大小
saveTreemapPNG(tm1, "tm1_2019.png", 4, 9.4, 9.4)  # 2019
saveTreemapPNG(tm2, "tm1_2020.png", 4, 8.8, 8.8)  # 2020
saveTreemapPNG(tm3, "tm1_2021.png", 3, 6.0, 6.0)  # 2021
saveTreemapPNG(tm4, "tm1_2022.png", 4, 7.8, 7.8)  # 2022
saveTreemapPNG(tm5, "tm1_2023.png", 5, 10.0, 10.0) # 2023
# 生成组合图
png("combined_treemap.png", width = 30, height = 30, units = "cm", res = 600)  # 降低组合图的分辨率
# 使用grid来绘制组合图
grid.newpage()
# 读取每个图像的大小
img1 <- png::readPNG("tm1_2019.png")
img2 <- png::readPNG("tm1_2020.png")
img3 <- png::readPNG("tm1_2021.png")
img4 <- png::readPNG("tm1_2022.png")
img5 <- png::readPNG("tm1_2023.png")
# 获取图像尺寸
img_sizes <- list(dim(img1), dim(img2), dim(img3), dim(img4), dim(img5))
# 计算每个图像的显示大小（单位：cm）
display_sizes <- lapply(img_sizes, function(size) {
list(width = size[2] / 300 * 2.54, height = size[1] / 300 * 2.54)  # 根据新的分辨率计算
})
# 放大倍数（降低放大倍数）
scale_factor <- 1.01  # 可以根据需要设置更小的放大倍数
# 根据实际图像大小和放大倍数绘制组合图
pushViewport(viewport(layout = grid.layout(3, 3,
widths = unit(c(0.3, 0.3, 0.3), "npc"),
heights = unit(c(0.3, 0.3, 0.3), "npc"))))
# 在指定位置绘制每个图，使用图像的实际尺寸和放大倍数
grid.raster(img1, width = unit(display_sizes[[1]]$width * scale_factor, "cm"),
height = unit(display_sizes[[1]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 2))  # 2019 (2,2)
grid.raster(img2, width = unit(display_sizes[[2]]$width * scale_factor, "cm"),
height = unit(display_sizes[[2]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 3))  # 2020 (2,3)
grid.raster(img3, width = unit(display_sizes[[3]]$width * scale_factor, "cm"),
height = unit(display_sizes[[3]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 1, layout.pos.col = 2))  # 2021 (1,2)
grid.raster(img4, width = unit(display_sizes[[4]]$width * scale_factor, "cm"),
height = unit(display_sizes[[4]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 1))  # 2022 (2,1)
grid.raster(img5, width = unit(display_sizes[[5]]$width * scale_factor, "cm"),
height = unit(display_sizes[[5]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 3, layout.pos.col = 2))  # 2023 (3,2)
dev.off()
# 保存每个图为 PNG 文件，使用较低的分辨率
saveTreemapPNG <- function(treemap, filename, label_size, width, height) {
png(filename, width = width * 0.5, height = height * 0.5, units = "cm", res = 800)  # 降低分辨率
drawTreemap(
treemap,
color_palette = custom_pal_1,
color_type = "custom_color",
color_level = 2,
label_level = c(1, 2),
label_size = c(1,0.5),
label_color = "black",
border_size = c(1.5, 0.5),
border_color = gray(0.6),
position = c(1, 1)
)
dev.off()
}
# 保存每个图的 PNG，设置对应的大小
saveTreemapPNG(tm1, "tm1_2019.png", 4, 9.4, 9.4)  # 2019
saveTreemapPNG(tm2, "tm1_2020.png", 4, 8.8, 8.8)  # 2020
saveTreemapPNG(tm3, "tm1_2021.png", 3, 6.0, 6.0)  # 2021
saveTreemapPNG(tm4, "tm1_2022.png", 4, 7.8, 7.8)  # 2022
saveTreemapPNG(tm5, "tm1_2023.png", 5, 10.0, 10.0) # 2023
# 生成组合图
png("combined_treemap.png", width = 30, height = 30, units = "cm", res = 300)  # 降低组合图的分辨率
# 使用grid来绘制组合图
grid.newpage()
# 读取每个图像的大小
img1 <- png::readPNG("tm1_2019.png")
img2 <- png::readPNG("tm1_2020.png")
img3 <- png::readPNG("tm1_2021.png")
img4 <- png::readPNG("tm1_2022.png")
img5 <- png::readPNG("tm1_2023.png")
# 获取图像尺寸
img_sizes <- list(dim(img1), dim(img2), dim(img3), dim(img4), dim(img5))
# 计算每个图像的显示大小（单位：cm）
display_sizes <- lapply(img_sizes, function(size) {
list(width = size[2] / 300 * 2.54, height = size[1] / 300 * 2.54)  # 根据新的分辨率计算
})
# 放大倍数（降低放大倍数）
scale_factor <- 1.01  # 可以根据需要设置更小的放大倍数
# 根据实际图像大小和放大倍数绘制组合图
pushViewport(viewport(layout = grid.layout(3, 3,
widths = unit(c(0.3, 0.3, 0.3), "npc"),
heights = unit(c(0.3, 0.3, 0.3), "npc"))))
# 在指定位置绘制每个图，使用图像的实际尺寸和放大倍数
grid.raster(img1, width = unit(display_sizes[[1]]$width * scale_factor, "cm"),
height = unit(display_sizes[[1]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 2))  # 2019 (2,2)
grid.raster(img2, width = unit(display_sizes[[2]]$width * scale_factor, "cm"),
height = unit(display_sizes[[2]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 3))  # 2020 (2,3)
grid.raster(img3, width = unit(display_sizes[[3]]$width * scale_factor, "cm"),
height = unit(display_sizes[[3]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 1, layout.pos.col = 2))  # 2021 (1,2)
grid.raster(img4, width = unit(display_sizes[[4]]$width * scale_factor, "cm"),
height = unit(display_sizes[[4]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 1))  # 2022 (2,1)
grid.raster(img5, width = unit(display_sizes[[5]]$width * scale_factor, "cm"),
height = unit(display_sizes[[5]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 3, layout.pos.col = 2))  # 2023 (3,2)
dev.off()
# 保存每个图为 PNG 文件，使用较低的分辨率
saveTreemapPNG <- function(treemap, filename, label_size, width, height) {
png(filename, width = width * 0.5, height = height * 0.5, units = "cm", res = 600)  # 降低分辨率
drawTreemap(
treemap,
color_palette = custom_pal_1,
color_type = "custom_color",
color_level = 2,
label_level = c(1, 2),
label_size = c(1,0.5),
label_color = "black",
border_size = c(1.5, 0.5),
border_color = gray(0.6),
position = c(1, 1)
)
dev.off()
}
# 保存每个图的 PNG，设置对应的大小
saveTreemapPNG(tm1, "tm1_2019.png", 4, 9.4, 9.4)  # 2019
saveTreemapPNG(tm2, "tm1_2020.png", 4, 8.8, 8.8)  # 2020
saveTreemapPNG(tm3, "tm1_2021.png", 3, 6.0, 6.0)  # 2021
saveTreemapPNG(tm4, "tm1_2022.png", 4, 7.8, 7.8)  # 2022
saveTreemapPNG(tm5, "tm1_2023.png", 5, 10.0, 10.0) # 2023
# 生成组合图
png("combined_treemap.png", width = 30, height = 30, units = "cm", res = 1000)  # 降低组合图的分辨率
# 使用grid来绘制组合图
grid.newpage()
# 读取每个图像的大小
img1 <- png::readPNG("tm1_2019.png")
img2 <- png::readPNG("tm1_2020.png")
img3 <- png::readPNG("tm1_2021.png")
img4 <- png::readPNG("tm1_2022.png")
img5 <- png::readPNG("tm1_2023.png")
# 获取图像尺寸
img_sizes <- list(dim(img1), dim(img2), dim(img3), dim(img4), dim(img5))
# 计算每个图像的显示大小（单位：cm）
display_sizes <- lapply(img_sizes, function(size) {
list(width = size[2] / 300 * 2.54, height = size[1] / 300 * 2.54)  # 根据新的分辨率计算
})
# 放大倍数（降低放大倍数）
scale_factor <- 1.01  # 可以根据需要设置更小的放大倍数
# 根据实际图像大小和放大倍数绘制组合图
pushViewport(viewport(layout = grid.layout(3, 3,
widths = unit(c(0.3, 0.3, 0.3), "npc"),
heights = unit(c(0.3, 0.3, 0.3), "npc"))))
# 在指定位置绘制每个图，使用图像的实际尺寸和放大倍数
grid.raster(img1, width = unit(display_sizes[[1]]$width * scale_factor, "cm"),
height = unit(display_sizes[[1]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 2))  # 2019 (2,2)
grid.raster(img2, width = unit(display_sizes[[2]]$width * scale_factor, "cm"),
height = unit(display_sizes[[2]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 3))  # 2020 (2,3)
grid.raster(img3, width = unit(display_sizes[[3]]$width * scale_factor, "cm"),
height = unit(display_sizes[[3]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 1, layout.pos.col = 2))  # 2021 (1,2)
grid.raster(img4, width = unit(display_sizes[[4]]$width * scale_factor, "cm"),
height = unit(display_sizes[[4]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 1))  # 2022 (2,1)
grid.raster(img5, width = unit(display_sizes[[5]]$width * scale_factor, "cm"),
height = unit(display_sizes[[5]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 3, layout.pos.col = 2))  # 2023 (3,2)
dev.off()
# 生成组合图
png("combined_treemap.png", width = 30, height = 30, units = "cm", res = 1500)  # 降低组合图的分辨率
# 使用grid来绘制组合图
grid.newpage()
# 读取每个图像的大小
img1 <- png::readPNG("tm1_2019.png")
img2 <- png::readPNG("tm1_2020.png")
img3 <- png::readPNG("tm1_2021.png")
img4 <- png::readPNG("tm1_2022.png")
img5 <- png::readPNG("tm1_2023.png")
# 获取图像尺寸
img_sizes <- list(dim(img1), dim(img2), dim(img3), dim(img4), dim(img5))
# 计算每个图像的显示大小（单位：cm）
display_sizes <- lapply(img_sizes, function(size) {
list(width = size[2] / 300 * 2.54, height = size[1] / 300 * 2.54)  # 根据新的分辨率计算
})
# 放大倍数（降低放大倍数）
scale_factor <- 1.01  # 可以根据需要设置更小的放大倍数
# 根据实际图像大小和放大倍数绘制组合图
pushViewport(viewport(layout = grid.layout(3, 3,
widths = unit(c(0.3, 0.3, 0.3), "npc"),
heights = unit(c(0.3, 0.3, 0.3), "npc"))))
# 在指定位置绘制每个图，使用图像的实际尺寸和放大倍数
grid.raster(img1, width = unit(display_sizes[[1]]$width * scale_factor, "cm"),
height = unit(display_sizes[[1]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 2))  # 2019 (2,2)
grid.raster(img2, width = unit(display_sizes[[2]]$width * scale_factor, "cm"),
height = unit(display_sizes[[2]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 3))  # 2020 (2,3)
grid.raster(img3, width = unit(display_sizes[[3]]$width * scale_factor, "cm"),
height = unit(display_sizes[[3]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 1, layout.pos.col = 2))  # 2021 (1,2)
grid.raster(img4, width = unit(display_sizes[[4]]$width * scale_factor, "cm"),
height = unit(display_sizes[[4]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 1))  # 2022 (2,1)
grid.raster(img5, width = unit(display_sizes[[5]]$width * scale_factor, "cm"),
height = unit(display_sizes[[5]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 3, layout.pos.col = 2))  # 2023 (3,2)
dev.off()
# 保存每个图为 PNG 文件，使用较低的分辨率
saveTreemapPNG <- function(treemap, filename, label_size, width, height) {
png(filename, width = width * 0.5, height = height * 0.5, units = "cm", res = 500)  # 降低分辨率
drawTreemap(
treemap,
color_palette = custom_pal_1,
color_type = "custom_color",
color_level = 2,
label_level = c(1, 2),
label_size = c(1,0.5),
label_color = "black",
border_size = c(1.5, 0.5),
border_color = gray(0.6),
position = c(1, 1)
)
dev.off()
}
# 保存每个图的 PNG，设置对应的大小
saveTreemapPNG(tm1, "tm1_2019.png", 4, 9.4, 9.4)  # 2019
saveTreemapPNG(tm2, "tm1_2020.png", 4, 8.8, 8.8)  # 2020
saveTreemapPNG(tm3, "tm1_2021.png", 3, 6.0, 6.0)  # 2021
saveTreemapPNG(tm4, "tm1_2022.png", 4, 7.8, 7.8)  # 2022
saveTreemapPNG(tm5, "tm1_2023.png", 5, 10.0, 10.0) # 2023
# 生成组合图
png("combined_treemap.png", width = 30, height = 30, units = "cm", res = 1500)  # 降低组合图的分辨率
# 使用grid来绘制组合图
grid.newpage()
# 读取每个图像的大小
img1 <- png::readPNG("tm1_2019.png")
img2 <- png::readPNG("tm1_2020.png")
img3 <- png::readPNG("tm1_2021.png")
img4 <- png::readPNG("tm1_2022.png")
img5 <- png::readPNG("tm1_2023.png")
# 获取图像尺寸
img_sizes <- list(dim(img1), dim(img2), dim(img3), dim(img4), dim(img5))
# 计算每个图像的显示大小（单位：cm）
display_sizes <- lapply(img_sizes, function(size) {
list(width = size[2] / 300 * 2.54, height = size[1] / 300 * 2.54)  # 根据新的分辨率计算
})
# 放大倍数（降低放大倍数）
scale_factor <- 1.01  # 可以根据需要设置更小的放大倍数
# 根据实际图像大小和放大倍数绘制组合图
pushViewport(viewport(layout = grid.layout(3, 3,
widths = unit(c(0.3, 0.3, 0.3), "npc"),
heights = unit(c(0.3, 0.3, 0.3), "npc"))))
# 在指定位置绘制每个图，使用图像的实际尺寸和放大倍数
grid.raster(img1, width = unit(display_sizes[[1]]$width * scale_factor, "cm"),
height = unit(display_sizes[[1]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 2))  # 2019 (2,2)
grid.raster(img2, width = unit(display_sizes[[2]]$width * scale_factor, "cm"),
height = unit(display_sizes[[2]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 3))  # 2020 (2,3)
grid.raster(img3, width = unit(display_sizes[[3]]$width * scale_factor, "cm"),
height = unit(display_sizes[[3]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 1, layout.pos.col = 2))  # 2021 (1,2)
grid.raster(img4, width = unit(display_sizes[[4]]$width * scale_factor, "cm"),
height = unit(display_sizes[[4]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 2, layout.pos.col = 1))  # 2022 (2,1)
grid.raster(img5, width = unit(display_sizes[[5]]$width * scale_factor, "cm"),
height = unit(display_sizes[[5]]$height * scale_factor, "cm"),
vp = viewport(layout.pos.row = 3, layout.pos.col = 2))  # 2023 (3,2)
dev.off()
